<!DOCTYPE html>
<html lang="en">
<head>

	<!-- Basic Page Needs
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
	<meta charset="utf-8">
	<title>Griddle - React Grid Component</title>
	<meta name="description" content="Griddle - React Grid component. ">
	<meta name="author" content="Ryan Lanciaux">

	<!-- Mobile Specific Metas
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- FONT
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
	<link href='//fonts.googleapis.com/css?family=Raleway:400,300,600' rel='stylesheet' type='text/css'>

	<!-- CSS
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
	<link rel="stylesheet" href="styles/normalize.css">
	<link rel="stylesheet" href="styles/skeleton.css">
	<link rel="stylesheet" href="styles/site.css">
	<link rel="stylesheet" href="styles/chartist.css">
	<!-- Favicon
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
	<link rel="icon" type="image/png" href="images/favicon.png" />

	<!-- Scripts
	–––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/react/0.13.2/JSXTransformer.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js"></script>
	<script src="scripts/Griddle.js"></script>
	<script src="scripts/GriddleWithCallback.js"></script>
	<script src="scripts/fakeData.js"></script>
	<script src="scripts/ChartistGraph.js"></script>
</head>
<body id="docs-page">
  <header class="background-primary-dark border-bottom border-secondary">
  	<div class="container">
  		<div class="row">
  			<div class="eight columns">
          <a href="index.html"><img src="images/griddle.png" alt="Griddle"/></a>
  			</div>
	  		<div class="four columns right">
          <iframe src="http://ghbtns.com/github-btn.html?user=GriddleGriddle&repo=Griddle&type=watch&count=true"
            allowtransparency="true" frameborder="0" scrolling="0" width="90" height="20"></iframe>
          <iframe src="http://ghbtns.com/github-btn.html?user=GriddleGriddle&repo=Griddle&type=fork&count=true"
            allowtransparency="true" frameborder="0" scrolling="0" width="90" height="20"></iframe>
            <br />
          <a href="quickstart.html" class="button border-light text-light big">Documentation</a>
	  		</div>
  		</div>
  	</div>
  </header>
	<div class="container page-content">
		<div class="row">
			<div class="two columns">
				<nav class="side">
					<ul>
						<li><a href="quickstart.html">Quickstart</a></li>
						<li><a href="styling.html">Styling</a></li>
						<li><a href="subgrids.html">Subgrids</a></li>
						<li><a href="customization.html">Customization</a></li>
						<li><a href="externalData.html">External Data</a></li>
						<li><a href="infiniteScroll.html">Infinite Scrolling</a></li>
						<li><a href="properties.html">Properties</a></li>
						<li class="border-top border-lighter-grey"><a href="https://reactjsnews.com/isomorphic-javascript-with-react-node/">Isomorphic Rendering <small>(at ReactJS News)</small></a>
					</ul>
				</nav>
			</div>
			<div class="ten columns docs">
				<h2 id="infinite-scroll">Infinite Scroll</h2>
<p>If you&#39;re looking to display multiple pages of data without the need to click &#39;Next&#39; or manually select a page, use Griddle&#39;s infinite scrolling feature! One will need to set the &#39;enableInfiniteScroll&#39; property to true in Griddle, as well as include the maximum height of the scrollable area (in pixels).</p>
<dl>
  <dt>enableInfiniteScroll</dt>
  <dd><strong>bool</strong> - Whether or not paging is controlled by scroll position, rather than navigation. Default: false</dd>
</dl>
<dl>
  <dt>bodyHeight</dt>
  <dd><strong>int</strong> - The height, in pixels, that the scrollable area should be displayed in. Default: null</dd>
</dl>
<dl>
  <dt>useFixedHeader (Optional)</dt>
  <dd><strong>bool</strong> - Whether or not to have fixed column headers when scrolling, which is accomplished by having Griddle represented in two tables (with the headers in the first). As Griddle doesn&#39;t make many assumptions about much styling, this will ensure that the table headers will be displayed above the scrollable table body. Default: false</dd>
</dl>
<dl>
  <dt>infiniteScrollLoadTreshold (Optional)</dt>
  <dd><strong>int</strong> - The height, in pixels, used to trigger paging. Changing this property should be a pretty rare occurrence. Default: 50</dd>
</dl>


<h5 id="example-">Example:</h5>
<pre><code><span class="tag">&lt;<span class="title">Griddle</span> <span class="attribute">results</span>=<span class="value">{fakeData}</span> <span class="attribute">columnMetadata</span>=<span class="value">{columnMeta}</span> <span class="attribute">resultsPerPage</span>=<span class="value">{5}</span> <span class="attribute">enableInfiniteScroll</span>=<span class="value">{true}</span> <span class="attribute">bodyHeight</span>=<span class="value">{400}</span>/&gt;</span></code></pre>
<div id="griddle-infinite-scroll"></div>

<script type="text/jsx">
  ReactDOM.render(<Griddle results={fakeData} columnMetadata={columnMeta} rowMetadata={rowMeta} resultsPerPage={5} enableInfiniteScroll={true} bodyHeight={400}/>, document.getElementById('griddle-infinite-scroll'));
</script>



<h3 id="fixed-header">Fixed Header</h3>
<p>Generally, when using infinite scroll on a table, fixed headers are pretty desirable. To accomplish this, the &#39;useFixedHeader&#39; property needs to be set to &#39;true&#39;.</p>
<p>Griddle handles fixed headers in an Infinite Scroll situation by utilizing two separate tables, one containing the &#39;<thead>&#39; and the other containing the &#39;<tbody>&#39; as well as the capability to scroll. As we mention above, Griddle doesn&#39;t like to make many assumptions about much styling, so this is our surefire way to make sure that the headers stay put.</p>
<h5 id="example-">Example:</h5>
<pre><code><span class="tag">&lt;<span class="title">Griddle</span> <span class="attribute">results</span>=<span class="value">{fakeData}</span> <span class="attribute">columnMetadata</span>=<span class="value">{columnMeta}</span> <span class="attribute">resultsPerPage</span>=<span class="value">{5}</span> <span class="attribute">enableInfiniteScroll</span>=<span class="value">{true}</span> <span class="attribute">useFixedHeader</span>=<span class="value">{true}</span> <span class="attribute">bodyHeight</span>=<span class="value">{400}</span>/&gt;</span></code></pre>
<div id="griddle-infinite-fixed-header"></div>

<script type="text/jsx">
    ReactDOM.render(<Griddle results={fakeData} columnMetadata={columnMeta} rowMetadata={rowMeta} resultsPerPage={5} enableInfiniteScroll={true} useFixedHeader={true} bodyHeight={400}/>, document.getElementById('griddle-infinite-fixed-header'));
</script>


<h3 id="external-results">External Results</h3>
<p>Feel free to scroll through your external data, too! When data is loading, the loading component will be appended to the end of the results.</p>
<h5 id="example-">Example:</h5>
<pre><code><span class="tag">&lt;<span class="title">GriddleWithCallback</span> <span class="attribute">showFilter</span>=<span class="value">{true}</span> <span class="attribute">getExternalResults</span>=<span class="value">{fakeDataMethod}</span>
 <span class="attribute">loadingComponent</span>=<span class="value">{Loading}</span> <span class="attribute">enableInfiniteScroll</span>=<span class="value">{true}</span> <span class="attribute">useFixedHeader</span>=<span class="value">{true}</span> <span class="attribute">bodyHeight</span>=<span class="value">{400}</span>/&gt;</span></code></pre>
<div id="griddle-external"></div>

<script type="text/jsx">
    var externalData = fakeData.slice(0, 53);

    var setDefault = function(original, value){
        return typeof original === 'undefined' ? value : original;
    }

    //this is a really ugly method for simulating a lot of the stuff that should be occuring on an API call or something of that nature
    var fakeDataMethod = function(filterString, sortColumn, sortAscending, page, pageSize, callback) {

        //need some ECMA6
        filterString = setDefault(filterString, null);
        sortColumn = setDefault(sortColumn, null);
        sortAscending = setDefault(sortAscending, null);
        page = setDefault(page, 0);
        pageSize = setDefault(pageSize, 5);
        callback = setDefault(callback, null);
        var initialIndex = page * pageSize;
        var endIndex = initialIndex + pageSize;

        setTimeout(function() {
            var results = [],
            sortedResults = null,
            totalResults = 0;


            //sort the results if sortColumnSet
      if(sortColumn&&sortColumn !== ""){
          sortedResults = _.sortBy(fakeData, function(item){
              return item[sortColumn];
          });

          if(sortAscending === false){
              sortedResults.reverse();
          }
      }

            //filter the results if it's there
            if (filterString&&filterString.length > 0) {
                var filteredResults = _.filter(sortedResults||fakeData,
                   function(item) {
                        var arr = _.values(item);
                        for(var i = 0; i < arr.length; i++){
                           if ((arr[i]||"").toString().toLowerCase().indexOf(filterString.toLowerCase()) >= 0){
                            return true;
                           }
                        }

                        return false;
                    });

                results = filteredResults.slice(initialIndex, endIndex);
                totalResults = filteredResults.length;

            } else {
                results = (sortedResults||fakeData).slice(initialIndex, endIndex);
                totalResults = (sortedResults||fakeData).length;
            }

            callback({
                results: results,
                totalResults: totalResults,
                pageSize: pageSize
            });
        }, 1000);
    };

    var Loading = React.createClass({
        getDefaultProps: function(){
            return {
                loadingText: "Loading"
            }
        },
        render: function(){
            var loadingStyle = {
                textAlign: "center",
                paddingBottom: "40px"
            };

            return <div className="loading container" style={loadingStyle}>{this.props.loadingText}</div>;
        }
    });

    ReactDOM.render(<GriddleWithCallback getExternalResults={fakeDataMethod} loadingComponent={Loading} enableInfiniteScroll={true} useFixedHeader={true} bodyHeight={400}/>, document.getElementById("griddle-external"));
</script>


<h4 id="cautions-">Cautions:</h4>
<p>When using infinite scroll on a table, re-renders of the Griddle component will cause the table to recreate itself - setting the scroll position back to 0, making the table appear to jump back to the top. To prevent this, specify the <code>key</code> attribute on <code>rowMetadata</code>. For more information please see the <a href="https://facebook.github.io/react/docs/reconciliation.html">React page on reconciliation</a>.</p>
<pre><code><span class="keyword">var</span> rowMetadata = {
      <span class="string">"key"</span>: <span class="string">"nameOfIndexInMyResultSet"</span>
    }
};

<span class="keyword">return</span> (
    <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"griddle-container"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">Griddle</span> <span class="attribute">results</span>=<span class="value">{this.state.rows}</span> <span class="attribute">enableInfiniteScroll</span>=<span class="value">{true}</span> <span class="attribute">rowMetadata</span>=<span class="value">{rowMetadata}</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
)</span></code></pre>

			</div>
		</div>
	</div>
  <div class="order-primary content-section background-darker-grey text-light-grey" id="about">
    <div class="container">
      <div class="row">
        <div class="ten columns offset-by-two">
          <p>Griddle is a project maintained by <a href="http://twitter.com/ryanlanciaux">Ryan Lanciaux</a> and <a href="http://www.twitter.com/joellanciaux">Joel Lanciaux</a> in collaboration with all of <a href="https://github.com/GriddleGriddle/Griddle/graphs/contributors">the awesome contributors!</a></p>
         	<small>
        		&copy; 2015 <a href="http://www.twitter.com/ryanlanciaux">Ryan Lanciaux</a> | <a href="https://www.github.com/DynamicTyped">DynamicTyped</a>
        	</small> 
        	<br />
          <small>
						Example data has been generated with <a href="http://json-generator.com">json-generator.com</a>. Any data that resembles real people, places, companies, etc. is coincidence.
          </small>
        </div>
      </div>
    </div>
  </div>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-58716212-1', 'auto');
	  ga('send', 'pageview');

	</script> 
</body>
</html>
